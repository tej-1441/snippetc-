{
	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"basic code template": {
		"prefix": "include",
		"body": [
		  "/*",
		  "source code by vishnu verma",
		  " ",
		  "tej_1441",
		  " ",
		  "it's my arrival.",
		  "*/",
		  "#include<bits/stdc++.h>",
		  "using namespace std;",
		  "#include <ext/pb_ds/assoc_container.hpp>",
		  "#include <ext/pb_ds/tree_policy.hpp>",
		  "using namespace __gnu_pbds;",
		  "#define ordered_set tree<int, null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update>",
		  "#define ordered_multiset tree<int, null_type, less_equal<int>, rb_tree_tag, tree_order_statistics_node_update>",
		  "      //this doesn't work for array so convert it into vector before calculating",
		  "      // this work for the container which can be transversed using for(auto it:container);",
		  "          void __print(int x) {cerr << x;}",
		  "          void __print(long x) {cerr << x;}",
		  "          void __print(long long x) {cerr << x;}",
		  "          void __print(unsigned x) {cerr << x;}",
		  "          void __print(unsigned long x) {cerr << x;}",
		  "          void __print(unsigned long long x) {cerr << x;}",
		  "          void __print(float x) {cerr << x;}",
		  "          void __print(double x) {cerr << x;}",
		  "          void __print(long double x) {cerr << x;}",
		  "          void __print(char x) {cerr << '\\'' << x << '\\'';}",
		  "          void __print(const char *x) {cerr << '\\\"' << x << '\\\"';}",
		  "          void __print(const string &x) {cerr << '\\\"' << x << '\\\"';}",
		  "          void __print(bool x) {cerr << (x ? \"true\" : \"false\");}",
		  "          template<typename T, typename V>",
		  "          void __print(const pair<T, V> &x) {cerr << '{'; __print(x.first); cerr << ','; __print(x.second); cerr << '}';}",
		  "          template<typename T>",
		  "          void __print(const T &x) {int f = 0; cerr << '{'; for (auto &i: x) cerr << (f++ ? \",\" : \"\"), __print(i); cerr << \"}\";}",
		  "          void _print() {cerr << \"]\\n\";}",
		  "          template <typename T, typename... V>",
		  "         void _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << \", \"; _print(v...);}",
		  "          #ifndef ONLINE_JUDGE",
		  "          #define debug(x...) cerr << \"[\" << #x << \"] = [\"; _print(x)",
		  "          #else",
		  "          #define debug(x...)",
		  "          #endif",
		  "",
		  "#define pb               push_back",
		  "#define ed               endl",
		  "#define doub(x);         cout<<fixed<<setprecision(20)<<x;",
		  "#define int              long long",
		  "#define ll               long long",
		  "#define ld               long double",
		  "#define db               double",
		  "#define ull              unsigned long long",
		  "#define mk               make_pair",
		  "#define pii              pair<int,int>",
		  "#define pldb             pair<ldb,ldb>",
		  "#define ff               first",
		  "#define ss               second",
		  "#define vull             vector<ull>",
		  "#define ub               upper_bound",
		  "#define lb               lower_bound",
		  "#define loop(i,a,b)       for(int i=a;i<b;i++)",
		  "#define mem1(a)          memset(a,-1,sizeof(a))",
		  "#define mem0(a)          memset(a,0,sizeof(a))",
		  "#define sorts(v)         sort(v.begin(),v.end())",
          "#define sortg(v)         sort(v.rbegin(),v.rend())",
		  "#define vi               vector<int>//vll v; means vector<long long>v;",
		  "#define vb               vector<bool>",
		  "#define vldb             vector<ldb>",
		  "#define vp               vector<pii>",
		  "#define vpldb            vector<pldb>",
		  "#define pqmin            priority_queue<ll,vector<ll>,greater<ll>>  //minheap",
		  "#define pq               priority_queue<int> //maxheap",
		  "#define pqmaxp           priority_queue<pair<int,int>>//pqr with pairs",
		  "#define pqminp           priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>",
		  "#define mldb             map<ldb,ldb>",
		  "#define us               unordered_set<ll>",
		  "#define ppc(x)         __builtin_popcount(x)",
		  "#define pp(x)          __builtin_parity(x)",
		  "#define ppll(x)        __builtin_parityll(x)",
		  "#define clz(x)         __builtin_clz(x)",
		  "#define ctz(x)         __builtin_ctz(x)",
		  "#define clzll(x)       __builtin_clzll(x)",
		  "#define ctzll(x)       __builtin_ctzll(x)",
		  "#define ppcll(x)       __builtin_popcountll(x)",
		  "#define maxx           1e9+7",
		  "#define minn          -(1e9+7)",
		  "ll mod=1000000000+7;//998244353;",
		  "ll inf=1e17;",
		  "",

		  "/*",
		  "order_of_key( val ) - - - > give no of element strictly less than the required val",
		  "find_by_order( k )  - - - - > kth element in set(counting from 0)",
		  "to make multiordered set use less_equal",
		  "to use pair type pair<int,int>",
		  "",
		  "*/",
		  "/*---------------------------------------------------------------------------------------------------*/",
		  "void print_vector ( vector<int>v ) { for ( int i=0 ; i < v.size() ; i++ ){ cout << v[i] <<' '; }cout << ed ; }",
		  "ll power(int a, int n, int p){int res = 1;a = a % p;if (a == 0) return 0;while (n > 0){ if (n & 1) res = (res*a) % p; n = n>>1; a = (1ll*a*a) % p;} return res;}",
		  "bool pred ( pair <int , int >p1 , pair< int , int > p2 ) { if ( p1.ss != p2.ss ) { return ( p1.ss < p2.ss ) ; } else { return ( p1.ff < p2.ff ) ; } }",
		  "void sort_second ( vector < pair < int , int > > &v ) { sort ( v.begin () , v.end () , pred ) ; }",
		  "template< typename type > type gcd ( type x , type y ) { return y ? gcd ( y , x % y ) : x ; } " ,
		  "template< typename type > type lcm ( type x , type y ) { return x/gcd ( x , y ) * y ; }",
		  "int countpf( int x ) { int ans=0 ; for ( int i=2; i * i <= x ; i ++ ) while( x % i == 0 ) ans++, x/=i;if(x>1) ans++;return ans;}",
		  "void normalize( pair < int , int > &p ){int val1 = p.ff ; int val2 = p.ss ; int g = gcd ( abs ( val1 ),abs( val2 ) );p.ff/=g;p.ss/=g;}",
		  "class compa",
          "{",
            "public:",
            "bool operator (  ) ( int a , int b)",
            "{",
                 "return( b < a );",
            "}",
          "};",  
		  "/*------------------------------------------------------------------------------------------------------*/",
		  "",
		  "int tt=0;",
		  "const int N=2e5+5;",
		  "bool prime[N];",
		  "vector<int>arr;",
		  "int n;",
		  "",
		  "void tej_1441()",
		  "{",
		  "    tt++;",
		  "    cin>>n;",
		  "    $1",
		  "",
		  "}",
		  "",
		  "",
		  "volatile double sink;",
		  "int32_t main()",
		  "{",
		  "ios::sync_with_stdio(false);",
		  "cin.tie(NULL);",
		  "//primegen()",
		  "",
		  "int t;",
		  "cin >> t;",
		  "while( t --)",
		  "tej_1441();",
		  "return(0);",
		  "}",
		  "",
		],
		"description": "basic code template"
	  },
	  "dijkstra algorithm(for finding single sources shortest path)": {
		"prefix": "dijkstra_algorithm",
		"body": [
		  "const int INF = 1000000000;",
		  "vector<vector<pair<int, int>>> adj;",
		  "//p is to restore the path",
		  "// here set is used considering the fact that it is a sparse graph",
		  "//sparse mean a graph having less number of edges what it actually can have",
		  "void dijkstra(int s, vector<int> & d, vector<int> & p) {",
		  "    int n = adj.size();",
		  "    d.assign(n, INF);",
		  "    p.assign(n, -1);",
		  "",
		  "    d[s] = 0;",
		  "    set<pair<int, int>> q;",
		  "    q.insert({0, s});",
		  "    while (!q.empty()) {",
		  "        int v = q.begin()->second;",
		  "        q.erase(q.begin());",
		  "",
		  "        for (auto edge : adj[v]) {",
		  "            int to = edge.first;",
		  "            int len = edge.second;",
		  "",
		  "            if (d[v] + len < d[to]) {",
		  "                q.erase({d[to], to});",
		  "                d[to] = d[v] + len;",
		  "                p[to] = v;",
		  "                q.insert({d[to], to});",
		  "            }",
		  "        }",
		  "    }",
		  "}",
		  "vector<int> restore_path(int s, int t, vector<int> const& p) {",
		  "    vector<int> path;",
		  "",
		  "    for (int v = t; v != s; v = p[v])",
		  "        path.push_back(v);",
		  "    path.push_back(s);",
		  "",
		  "    reverse(path.begin(), path.end());",
		  "    return path;",
		  "}"
		],
		"description": "dijkstra algorithm(for finding single sources shortest path)"
	  },
	  "articulation point in graph": {
		"prefix": "articulation_point",
		"body": [
		  "",
		  "int n; // number of nodes",
		  "vector<vector<int>> adj; // adjacency list of graph",
		  "",
		  "vector<bool> visited;",
		  "vector<int> tin, low;",
		  "int timer;",
		  "void IS_CUTPOINT(int v)",
		  "{",
		  "  cout<<v<<ed;",
		  "}",
		  "void dfs(int v, int p = -1) {",
		  "    visited[v] = true;",
		  "    tin[v] = low[v] = timer++;",
		  "    int children=0;",
		  "    for (int to : adj[v]) {",
		  "        if (to == p) continue;",
		  "        if (visited[to]) {",
		  "            low[v] = min(low[v], tin[to]);",
		  "        } else {",
		  "            dfs(to, v);",
		  "            low[v] = min(low[v], low[to]);",
		  "            if (low[to] >= tin[v] && p!=-1)",
		  "                IS_CUTPOINT(v);",
		  "            ++children;",
		  "        }",
		  "    }",
		  "    if(p == -1 && children > 1)",
		  "        IS_CUTPOINT(v);",
		  "}",
		  "",
		  "void find_cutpoints() {",
		  "    timer = 0;",
		  "    visited.assign(n, false);",
		  "    tin.assign(n, -1);",
		  "    low.assign(n, -1);",
		  "    for (int i = 0; i < n; ++i) {",
		  "        if (!visited[i])",
		  "            dfs (i);",
		  "    }",
		  "}"
		],
		"description": "articulation point in graph"
	  },
	  "finding strongly connected component in the directed graph": {
		"prefix": "strongly_connected_component",
		"body": [
		  "vector<int> adj[N], adj_rev[N];",
		  "vector<bool> used;",
		  "vector<int> order, component;",
		  "",
		  "void dfs1(int v) {",
		  "    used[v] = true;",
		  "",
		  "    for (auto u : adj[v])",
		  "        if (!used[u])",
		  "            dfs1(u);",
		  "",
		  "    order.push_back(v);",
		  "}",
		  "",
		  "void dfs2(int v) {",
		  "    used[v] = true;",
		  "    component.push_back(v);",
		  "",
		  "    for (auto u : adj_rev[v])",
		  "        if (!used[u])",
		  "            dfs2(u);",
		  "    // cout<<v<<\" \";",
		  "}",
		  "",
		  "int32_t main() {",
		  "    int n,m;",
		  "    // ... read n ...",
		  "",
		  "     cin>>n>>m;",
		  "    for (int i=0;i<m;i++) {",
		  "        int a, b;",
		  "        cin>>a>>b;",
		  "        // ... read next directed edge (a,b) ...",
		  "        adj[a].push_back(b);",
		  "        adj_rev[b].push_back(a);",
		  "    }",
		  "",
		  "    used.assign(n, false);",
		  "",
		  "    for (int i = 0; i < n; i++)",
		  "        if (!used[i])",
		  "            dfs1(i);",
		  "",
		  "    used.assign(n, false);",
		  "    reverse(order.begin(), order.end());",
		  "",
		  "    for (auto v : order)",
		  "        if (!used[v]) {",
		  "            dfs2 (v);",
		  "            ",
		  "          for(int i=0;i<component.size();i++)",
		  "          {",
		  "            cout<<component[i]<<\" \";",
		  "          }",
		  "          cout<<ed;",
		  "",
		  "            // ... processing next component ...",
		  "",
		  "            component.clear();",
		  "        }",
		  "}"
		],
		"description": "finding strongly connected component in the directed graph"
	  },
	  "offline bridges in graph": {
		"prefix": "offlinebridge_graphs",
		"body": [
		  "int n; // number of nodes",
		  "vector<vector<int>> adj; // adjacency list of graph",
		  "vector<bool> visited;",
		  "vector<int> tin, low;",
		  "int timer;",
		  "void IS_BRIDGE(int u,int v)",
		  "{",
		  "  cout<<u<<\" \"<<v<<ed;",
		  "}",
		  "// source vertex and parent is considered;",
		  "void dfs(int v, int p = -1) {",
		  "    visited[v] = true;",
		  "    tin[v] = low[v] = timer++;",
		  "    for (int to : adj[v]) {",
		  "        if (to == p) continue;",
		  "        if (visited[to]) {",
		  "            low[v] = min(low[v], tin[to]);",
		  "        } else {",
		  "            dfs(to, v);",
		  "            low[v] = min(low[v], low[to]);",
		  "            if (low[to] > tin[v])",
		  "                IS_BRIDGE(v, to);",
		  "        }",
		  "    }",
		  "}",
		  "",
		  "void find_bridges() {",
		  "    timer = 0;",
		  "    visited.assign(n, false);",
		  "    tin.assign(n, -1);",
		  "    low.assign(n, -1);",
		  "    for (int i = 0; i < n; ++i) {",
		  "        if (!visited[i])",
		  "            dfs(i);",
		  "    }",
		  "}"
		],
		"description": "bridges in graph"
	  },
	  "prims algorithm for dense graph": {
		"prefix": "dense_prims_algorithm",
		"body": [
		  "// dense graph cannot be solved by the krushkal algorithms.",
		  "//time complexity is O(n2) or say O(v2); ",
		  "int n;",
		  "vector<vector<int>> adj; // adjacency matrix of graph",
		  "const int INF = 1000000000; // weight INF means there is no edge",
		  "",
		  "struct Edge {",
		  "    int w = INF, to = -1;",
		  "};",
		  "",
		  "void prim() {",
		  "    int total_weight = 0;",
		  "    vector<bool> selected(n, false);",
		  "    vector<Edge> min_e(n);",
		  "    min_e[0].w = 0;",
		  "",
		  "    for (int i=0; i<n; ++i) {",
		  "        int v = -1;",
		  "        for (int j = 0; j < n; ++j) {",
		  "            if (!selected[j] && (v == -1 || min_e[j].w < min_e[v].w))",
		  "                v = j;",
		  "        }",
		  "",
		  "        if (min_e[v].w == INF) {",
		  "            cout << \"No MST!\" << endl;",
		  "            exit(0);",
		  "        }",
		  "",
		  "        selected[v] = true;",
		  "        total_weight += min_e[v].w;",
		  "        if (min_e[v].to != -1)",
		  "            cout << v << \" \" << min_e[v].to << endl;",
		  "",
		  "        for (int to = 0; to < n; ++to) {",
		  "            if (adj[v][to] < min_e[to].w)",
		  "                min_e[to] = {adj[v][to], v};",
		  "        }",
		  "    }",
		  "",
		  "    cout << total_weight << endl;",
		  "}"
		],
		"description": "prims algorithm for dense graph"
	  },
	  "prims algorithm for sparse graph": {
		"prefix": "sparse_prims_algorithm",
		"body": [
		  "// this prims algorithm is for the sparse graph",
		  "// not for the dense graph",
		  "const int INF = 1000000000;",
		  "",
		  "struct Edge {",
		  "    int w = INF, to = -1;",
		  "    bool operator<(Edge const& other) const {",
		  "        return make_pair(w, to) < make_pair(other.w, other.to);",
		  "    }",
		  "};",
		  "",
		  "int n;",
		  "vector<vector<Edge>> adj;",
		  "",
		  "void prim() {",
		  "    int total_weight = 0;",
		  "    vector<Edge> min_e(n);",
		  "    min_e[0].w = 0;",
		  "    set<Edge> q;",
		  "    q.insert({0, 0});",
		  "    vector<bool> selected(n, false);",
		  "    for (int i = 0; i < n; ++i) {",
		  "        if (q.empty()) {",
		  "            cout << \"No MST!\" << endl;",
		  "            exit(0);",
		  "        }",
		  "",
		  "        int v = q.begin()->to;",
		  "        selected[v] = true;",
		  "        total_weight += q.begin()->w;",
		  "        q.erase(q.begin());",
		  "",
		  "        if (min_e[v].to != -1)",
		  "            cout << v << \" \" << min_e[v].to << endl;",
		  "",
		  "        for (Edge e : adj[v]) {",
		  "            if (!selected[e.to] && e.w < min_e[e.to].w) {",
		  "                q.erase({min_e[e.to].w, e.to});",
		  "                min_e[e.to] = {e.w, v};",
		  "                q.insert({e.w, e.to});",
		  "            }",
		  "        }",
		  "    }",
		  "",
		  "    cout << total_weight << endl;",
		  "}",
		  ""
		],
		"description": "prims algorithm for sparse graph"
	  },
	  "minimum spanning tree with krushkal's algorithms": {
		"prefix": "krushkals_algorithm",
		"body": [
		  "vector<int> parent, rank;",
		  "",
		  "void make_set(int v) {",
		  "    parent[v] = v;",
		  "    rank[v] = 0;",
		  "}",
		  "",
		  "int find_set(int v) {",
		  "    if (v == parent[v])",
		  "        return v;",
		  "    return parent[v] = find_set(parent[v]);",
		  "}",
		  "",
		  "void union_sets(int a, int b) {",
		  "    a = find_set(a);",
		  "    b = find_set(b);",
		  "    if (a != b) {",
		  "        if (rank[a] < rank[b])",
		  "            swap(a, b);",
		  "        parent[b] = a;",
		  "        if (rank[a] == rank[b])",
		  "            rank[a]++;",
		  "    }",
		  "}",
		  "",
		  "struct Edge {",
		  "    int u, v, weight;",
		  "    bool operator<(Edge const& other) {",
		  "        return weight < other.weight;",
		  "    }",
		  "};",
		  "",
		  "int n;",
		  "vector<Edge> edges;",
		  "",
		  "int cost = 0;",
		  "vector<Edge> result;",
		  "parent.resize(n);",
		  "rank.resize(n);",
		  "for (int i = 0; i < n; i++)",
		  "    make_set(i);",
		  "",
		  "sort(edges.begin(), edges.end());",
		  "",
		  "for (Edge e : edges) {",
		  "    if (find_set(e.u) != find_set(e.v)) {",
		  "        cost += e.weight;",
		  "        result.push_back(e);",
		  "        union_sets(e.u, e.v);",
		  "    }",
		  "}"
		],
		"description": "minimum spanning tree with krushkal's algorithms"
	  },
	  "bellman ford algorithm for single sources shortest path considering the negative edge": {
		"prefix": "bellman-ford",
		"body": [
		  "struct edge",
		  "{",
		  "    int a, b, cost;",
		  "};",
		  "int n, m, v;",
		  "vector<edge> e;",
		  "const int INF = 1000000000;",
		  "void solve()",
		  "{",
		  "    vector<int> d (n, INF);",
		  "    d[v] = 0;",
		  "    vector<int> p (n, -1);",
		  "",
		  "    for (;;)",
		  "    {",
		  "        bool any = false;",
		  "        for (int j = 0; j < m; ++j)",
		  "            if (d[e[j].a] < INF)",
		  "                if (d[e[j].b] > d[e[j].a] + e[j].cost)",
		  "                {",
		  "                    d[e[j].b] = d[e[j].a] + e[j].cost;",
		  "                    p[e[j].b] = e[j].a;",
		  "                    any = true;",
		  "                }",
		  "        if (!any)  break;",
		  "    }",
		  "",
		  "    if (d[t] == INF)",
		  "        cout << \"No path from \" << v << \" to \" << t << \".\";",
		  "    else",
		  "    {",
		  "        vector<int> path;",
		  "        for (int cur = t; cur != -1; cur = p[cur])",
		  "            path.push_back (cur);",
		  "        reverse (path.begin(), path.end());",
		  "",
		  "        cout << \"Path from \" << v << \" to \" << t << \": \";",
		  "        for (size_t i=0; i<path.size(); ++i)",
		  "            cout << path[i] << ' ';",
		  "    }",
		  "}"
		],
		"description": "bellman ford algorithm for single sources shortest path considering the negative edge"
	  },
    "all operation of segment tree": {
		"prefix": "segment_tree",
		"body": [
		  "const int N = 1e5;  // limit for array size",
		  "int n;  // array size",
		  "int t[2 * N];",
		  "",
		  "void build() {  // build the tree",
		  "  for (int i = n - 1; i > 0; --i) t[i] = t[i<<1] + t[i<<1|1];",
		  "}",
		  "",
		  "void modify(int p, int value) {  // set value at position p",
		  "  for (t[p += n] = value; p > 1; p >>= 1) t[p>>1] = t[p] + t[p^1];",
		  "}",
		  "",
		  "int query(int l, int r) {  // sum on interval [l, r)",
		  "  int res = 0;",
		  "  for (l += n, r += n; l < r; l >>= 1, r >>= 1) {",
		  "    if (l&1) res += t[l++];",
		  "    if (r&1) res += t[--r];",
		  "  }",
		  "  return res;",
		  "}",
		  "",
		  "int main() {",
		  "  cin>>n;",
		  "  for (int i = 0; i < n; ++i) scanf(\"%d\", t + n + i);",
		  "  build();",
		  "  modify(0, 1);",
		  "  printf(\"%d\\n\", query(3, 11));",
		  "  return 0;",
		  "// }",
		  "// Some people begin to struggle and invent something too complex when the operations are inverted, for example:",
		  "",
		  "// add a value to all elements in some interval;",
		  "// compute an element at some position.",
		  "// But all we need to do in this case is to switch the code in methods modify and query as follows:",
		  "",
		  "// void modify(int l, int r, int value) {",
		  "//   for (l += n, r += n; l < r; l >>= 1, r >>= 1) {",
		  "//     if (l&1) t[l++] += value;",
		  "//     if (r&1) t[--r] += value;",
		  "//   }",
		  "// }",
		  "",
		  "// int query(int p) {",
		  "//   int res = 0;",
		  "//   for (p += n; p > 0; p >>= 1) res += t[p];",
		  "//   return res;",
		  "// }",
		  "",
		  "// Non-commutative combiner functions",
		  "// For now we considered only the simplest combiner function — addition. It is commutative, which means the order of operands doesn't matter, we have a + b = b + a. The same applies to min and max, so we can just change all occurrences of + to one of those functions and be fine. But don't forget to initialize query result to infinity instead of 0.",
		  "",
		  "",
		  "// void modify(int p, const S& value) {",
		  "//   for (t[p += n] = value; p >>= 1; ) t[p] = combine(t[p<<1], t[p<<1|1]);",
		  "// }",
		  "",
		  "// S query(int l, int r) {",
		  "//   S resl, resr;",
		  "//   for (l += n, r += n; l < r; l >>= 1, r >>= 1) {",
		  "//     if (l&1) resl = combine(resl, t[l++]);",
		  "//     if (r&1) resr = combine(t[--r], resr);",
		  "//   }",
		  "//   return combine(resl, resr);",
		  "// }"
		],
		"description": "all operation of segment tree"
	  },
	"disjoint and union ": {
		"prefix": [
			"disjoint-union"
		],
		"body": [
			"\n",
			"const int N=10000;",
	       "int parent[N],ranks[N];",
		   "void inti()",
		   "{",
			"   for(int i=0;i<N;i++)",
			"    {",
			"       parent[i]=i;",
			"       ranks[i]=0;",
			"    }",
			"}",
			"int find(int x)",
			"{",
		    "    if(x==parent[x])",
		    "     {",
			"       return(x);",
		    "     }",
			"    else",
		    "     {",
			"       return(parent[x]=find(parent[x]));",
			"     }",
			" }",
		   "void unions(int x,int y)",
		   "{",
			"   int xx=find(x);",
			"   int yy=find(y);",
		    "   if(ranks[xx]<ranks[yy])",
			"   {",
			"    parent[xx]=yy;",
			"   }",
			"   if(ranks[xx]>ranks[yy])",
			"   {",
			"      parent[yy]=xx;",
			"   }",
			"   else",
			"   {",
			"      parent[yy]=xx;",
			"      ranks[xx]++;",
			"   }",
		    " }",
		],
		"description": "this is a c++ snippet for disjoint and value",
	},
	"square root decomposition ": {
		"prefix": [
			"mo theorum"
		],
		"body": [
		" #include<bits/stdc++.h>",
		" using namespace std;",
         "const int blk=700;//for1e5",
         "struct query",
		 "{",
          "int l,r,i;",
		 "};",
         "query q[200000];",
		 "int arr[30000],ans[2000000],cnt=0,fre[20000];",
		 "bool cmp(query a,query b)", 
		 "{",
		 "  if(a.l/blk !=b.l/blk)",
		 "  {",
		 "    return(a.l/blk < b.l/blk);",    
		 "  }",
		 "   else",
		 "   {" ,
		 "    return(a.r<b.r);",
		"   }",
		" }",
		"void add(int pos)",
		"{",
		"   fre[arr[pos]]++;",
		"   if(fre[arr[pos]]==1)",
		"   {",
		"     cnt++;",
		"   }",
		"}",
		"void remove(int pos)",
		"{",
		"   fre[arr[pos]]--;",
		"   if(fre[arr[pos]]==0)",
		"    cnt--;",
		"}",
		"int main()",
		"{",
		"    int n,qr1;",
		"    cin>>n;",
		"   for(int i=0;i<n;i++)",
		"   {",
		"      cin>>arr[i];",
		"   }",
		"   cin>>qr1;",
		"   for(int i=0;i<qr1;i++)",
		"   {",
		"       cin>>q[i].l>>q[i].r;",
		"       q[i].i=i;q[i].l--;q[i].r--;",
		"   }",
		"   sort(q,q+qr1,cmp);",
		"   int ml=0,mr=-1;",
		"   for(int i=0;i<qr1;i++)",
		"   {",
		"       int l=q[i].l;",
		"       int r=q[i].r;",
		"       while(ml>l)",
		"       {",
		"           ml--;",
		"           add(ml);",
		"       }",
		"       while(ml<l)",
		"       {",
		"           remove(ml);",
		"           ml++;",
		"       }",
		"       while(mr>r)",
		"       {",
		"           remove(mr);",
		"           mr--;",
		"       }",
		"       while(mr<r)",
		"       {",
		"           mr++;",
		"           add(mr);",
		"       }",
		"     ans[q[i].i]=cnt;",
		"    }",
		"   for(int i=0;i<qr1;i++)",
		"   {",
		"     cout<<ans[i]<<ed;",
		"   }",
		],
		"description": "this is a c++ snippet for disjoint and value",
},
"all funtion for sparse table": {
	"prefix": "sparse_table",
	"body": [
	  "const int N=11000;",
	  "const int k=25;",
	  "int st[N][k];",
	  "int logs[N];",
	  "int n;",
	  "int arr[N];",
	  "void logfun()",
	  "{",
	  "logs[1]=0;",
	  "for(int i=2;i<=N;i++)",
	  "{",
	  "logs[i]=logs[i/2] + 1;",
	  "}",
	  "}",
	  "void build()",
	  "{",
	  "for(int i=0;i<n;i++)",
	  "{",
	  "st[i][0]=arr[i];",
	  "}",
	  "for(int j=1;j<=k;j++)",
	  "{",
	  "for(int i=0;i+(1<<j)<=n;i++)",
	  "{",
	  "st[i][j]=min(st[i][j-1],st[i+(1<<(j-1))][j-1]);",
	  "}",
	  "}",
	  "}",
	  "//int rangesum(int l,int r)",
	  "//{",
	  "//long long sum = 0;",
	  "//for (int j = K; j >= 0; j--) {",
		 "// if ((1 << j) <= r - l + 1) {",
			 "// sum += st[l][r];",
			 "// l += 1 << j;",
		 "//}",
	  "//}",
	  "//return(sum);",
	  "//}",
	  "void solve()",
	  "{",
	  "cin>>n;",
	  "int arr[n];",
	  "for(int i=0;i<n;i++)",
	  "{",
	  "cin>>arr[i];",
	  "}",
	  "int q;",
	  "cin>>q;",
	  "while(q--)",
	  "{",
	  "int l,r;",
	  "cin>>l>>r;",
	  "int j=logs[r-l+1];",
	  "int minimum=min(st[l][j],st[r-(1<<j)+1][j]);",
	  "cout<<minimum<<ed;",
	  "}",
	  "}"
	],
	"description": "all funtion for sparse table"
  },
  "calculating factorial modulo some prime number ": {
	"prefix": "factorial_modulo",
	"body": [
	  "const int N=1e5;",
	  "#define NCR",
	  "#define PRIME mod",
	  "int pw(int a,int p=mod-2,int MOD=mod){",
	  "int result = 1;",
	  "while (p > 0) {",
	  "  if (p & 1)",
	  "     result = a * result % MOD;",
	  "   a = a * a % MOD;",
	  "  p >>= 1;",
	  " }",
	  " return result;",
	  "}",
	  "int fact[N],invfact[N];",
	  "void init(){",
	  " int p=PRIME;",
	  " fact[0]=1;",
	  " int i;",
	  " for(i=1;i<N;i++){",
	  "     fact[i]=i*fact[i-1]%p;",
	  " }",
	  " i--;",
	  " invfact[i]=pw(fact[i],p-2,p);",
	  " for(i--;i>=0;i--){",
	  "     invfact[i]=invfact[i+1]*(i+1)%p;",
	  " }",
	  "}",
	  "int ncr(int n,int r){",
	  " if(r > n || n < 0 || r < 0)return 0;",
	  " return fact[n]*invfact[r]%PRIME*invfact[n-r]%PRIME;",
	  "}",
	  ""
	],
	"description": "calculating factorial modulo some prime number "
  },
  "all purpose segment tree": {
	"prefix": "allpurpose_segment",
	"body": [
	  " ",
	  "const int N = 1e5 + 5;",
	  "const int INF = 1e9;",
	  " ",
	  " ",
	  "/*",
	  "note some time creating the segment tree as such not work so create it using array",
	  "generally in case of min and max finding create segment tree  using array",
	  " access using variable of nodes",
	  "KEYNOTES:",
	  "------------------------------------------",
	  "merge(X,identity_element) = X",
	  "------------------------------------------",
	  "------------------------------------------",
	  "identity_transformation.combine(X) = X",
	  "------------------------------------------",
	  "------------------------------------------",
	  "ALWAYS: older_update.combine(newer_update)",
	  "------------------------------------------",
	  "*/",
	  " ",
	  " ",
	  " ",
	  "// example: addition: identity element is 0",
	  " ",
	  "// a + 0 = a or 0 + a = a",
	  " ",
	  "// min(x,INF) = x",
	  " ",
	  "struct node",
	  "{",
	  " long long v=0;    // 1",
	  " // use more variables if you want more information",
	  " // these default values should be identity_element",
	  " node(){}",
	  " node(int val){",
	  "   v= val; // 2",
	  " }",
	  " void merge(const node &l,const node &r){ // store the thing you wanna query",
	  " ",
	  "   v = (l.v+r.v); //3",
	  "",
	  "   // if we wanted the maximum, then we would do",
	  "   // like v = max(l.v,r.v)",
	  " }",
	  "};",
	  " ",
	  "// example: add on a range: identity transformation = 0",
	  "// old += new",
	  " ",
	  "// if old is identity which is 0, then 0 + new which new",
	  " ",
	  "struct update",
	  "{",
	  " int v = 0; // 4",
	  " // use more variables if you want more information",
	  " // these default values should be identity_transformation",
	  " update(){}",
	  " update(int val){",
	  "   v = val; // 5",
	  " }",
	  " // combine the current update with the other update (see keynotes)",
	  "//mean to say curr+prev or curr",
	  " void combine(update &other,const int32_t &tl,const int32_t &tr){",
	  "     v += other.v; // 6",
	  "        //simply mean to say what man need to remember",
	  "     // you can be sure that the \"other\" is newer than current",
	  "        //older will combine to newer",
	  " ",
	  " }",
	  " // store the correct information in the node x",
	  "//instant changes applied to the node",
	  " void apply(node &x,const int32_t &tl,const int32_t &tr){",
	  " ",
	  "     // no change in freq",
	  "     x.v=(tr-tl+1)*v;    //7",
	  " ",
	  " }",
	  "};",
	  " ",
	  "// template<typename node,typename update>",
	  "struct segtree",
	  "{",
	  " int len;",
	  " vector<node> t;",
	  " vector<update> u;",
	  " vector<bool> lazy;",
	  " node identity_element;",
	  " update identity_transformation;",
	  " segtree(int l){",
	  "     len = l;",
	  "    t.resize(4 * len);",
	  "     u.resize(4 * len);",
	  "     lazy.resize(4 * len);",
	  "     identity_element = node();",
	  "     identity_transformation = update();",
	  " }",
	  " ",
	  " void pushdown(const int32_t &v, const int32_t &tl, const int32_t &tr){",
	  "     if(!lazy[v]) return;",
	  "     int32_t tm = (tl + tr) >> 1;",
	  "     apply(v<<1,tl,tm,u[v]);",
	  "     apply(v<<1|1,tm+1,tr,u[v]);",
	  "     u[v] = identity_transformation;",
	  "     lazy[v] = 0;",
	  " }",
	  " ",
	  " void apply(const int32_t &v, const int32_t &tl, const int32_t &tr, update upd){",
	  "       if(tl != tr){",
	  "         lazy[v] = 1;",
	  "         u[v].combine(upd,tl,tr);",
	  "     }",
	  "     upd.apply(t[v],tl,tr);",
	  " }",
	  " ",
	  " template<typename T>",
	  " void build(const T &arr,const int32_t &v, const int32_t &tl, const int32_t &tr){",
	  "    if(tl == tr){",
	  "        t[v] = arr[tl];",
	  "        return;",
	  "     }",
	  "     int32_t tm = (tl + tr) >> 1;",
	  "     build(arr,v<<1,tl,tm);",
	  "     build(arr,v<<1|1,tm+1,tr);",
	  "     t[v].merge(t[v<<1],t[v<<1|1]);",
	  " }",
	  " ",
	  " node query(const int32_t &v,const int32_t &tl,const int32_t &tr,const int32_t &l,const int32_t &r){",
	  "    if(l > tr || r < tl){",
	  "         return identity_element;",
	  "     }",
	  "    if(tl >= l && tr <= r){",
	  "         return t[v];",
	  "    }",
	  "    pushdown(v,tl,tr);",
	  "     int32_t tm = (tl + tr) >> 1;",
	  "     node a = query(v<<1,tl,tm,l,r),b = query(v<<1|1,tm+1,tr,l,r),ans;",
	  "     ans.merge(a,b);",
	  "     return ans;",
	  " }",
	  " ",
	  " // rupd = range update",
	  " void rupd(const int32_t &v,const int32_t &tl,const int32_t &tr,const int32_t &l,const int32_t &r,const update &upd){",
	  "     if(l > tr || r < tl){",
	  "        return;",
	  "     }",
	  "     if(tl >= l && tr <= r){",
	  "         apply(v,tl,tr,upd);",
	  "         return;",
	  "    }",
	  "     pushdown(v,tl,tr);",
	  "     int32_t tm = (tl + tr) >> 1;",
	  "     rupd(v<<1,tl,tm,l,r,upd);",
	  "     rupd(v<<1|1,tm+1,tr,l,r,upd);",
	  "     t[v].merge(t[v<<1],t[v<<1|1]);",
	  " }",
	  " ",
	  " public:",
	  " template<typename T>",
	  " void build(const T &arr){",
	  "      build(arr,1,0,len-1);",
	  " }",
	  " node query(const int32_t &l,const int32_t &r){",
	  "       return query(1,0,len-1,l,r);",
	  " }",
	  " void rupd(const int32_t &l,const int32_t &r,const update &upd){",
	  "     rupd(1,0,len-1,l,r,upd);",
	  " }",
	  "};",
	  " ",
	  "int main(){",
	  "",
	  "",
	  "int n,q;",
	  "cin>>n>>q;",
	  "   segtree s(n);",
	  "//  vector<int>v(100);",
	  "//  for(int i=0;i<n;i++)",
	  "//  {",
	  "//    long long val;",
	  "//    cin>>val;",
	  "//    v.push_back(val);",
	  "",
	  "//  }",
	  "//  s.build(v);",
	  " for(int i=0;i<n;i++)",
	  " {",
	  "   long long val;",
	  "   cin>>val;",
	  "   s.rupd(i,i,val);",
	  "  //  cout<<s.query(i,i).v<<\" \";",
	  " }",
	  "//   for(int i=0;i<n;i++)",
	  "//  {",
	  "//    cout<<s.query(i,i).v<<\" \";",
	  "//  }",
	  "//  cout<<endl;",
	  "for(int i=0;i<q;i++)",
	  "{",
	  "    int val;",
	  "    cin>>val;",
	  "    if(val==1)",
	  "    {",
	  "    int a,b;",
	  "    cin>>a>>b;",
	  "    a--;",
	  "    // b--;",
	  "s.rupd(a,a,b);",
	  "//cout<<s.query(3,7).v<<endl;",
	  "",
	  " }",
	  "    else",
	  "    {",
	  "        int p;",
	  "        int p1;",
	  "        cin>>p>>p1;",
	  "        p--;",
	  "        p1--;",
	  "        cout<<s.query(p,p1).v<<endl;",
	  "    }",
	  "",
	  "}",
	  " return 0;",
	  "}",
	  " ",
	  " ",
	  " ",
	  " ",
	  "// how to define the behaviour or the nature of the ",
	  "// updates and queries",
	  " ",
	  " ",
	  "// this segtree was sum in range and add on range",
	  " ",
	  " ",
	  "// let's change it to -> (sum on range) and (set all values on range)",
	  " ",
	  " ",
	  " ",
	  "// let's make the one from the question earlier",
	  " ",
	  "// get min element and frequency of min element on a range AND add on a range"
	],
	"description": "all purpose segment tree"
  },
"gives the number of coprime number till n": {
	"prefix": [
		"phi"
	],
	"body": [
		"int phi(int n)",
		"{",
		"   int res=n;",
		"   for(int i=2;i*i<=n;i++)",
		"   {",
		"       if(n%i==0)",
		"       {",
		"       res=res/i;",
		"       res=res*(i-1);",
		"       while(n%i==0)",
		"       {",
		"           n=n/i;",
		"       }",
		"       }",
		"       }",
		"   if(n>1)",
		"   {",
		"       res=res/n;",
		"       res*=(n-1);",
		"   }",
		"   return(res);",
		"}",
	],
	"description": "this is a c++ snippet for number of coprime till an integer n",
},
"gives the prime factor of long long n": {
	"prefix": [
		"prime_factors"
	],
	"body": [
		"vector<ll>factor;",
		"void primefactors(ll n)",
		"{",
		"    while(n%2==0)",
		"    {",
		"       factor.pb(2);",
		"       n=n/2;",
		"    }",
		"    for(ll i=3;i<=sqrt(n);i+=2)",
		"    {",
		"        while(n%i==0)",
		"        {",
		"           factor.pb(i);",
		"           n=n/i;",
		"        }",
		"    }",
		"    if(n>2)",
		"    {",
		"       factor.pb(n);",
		"    }",
		"}",
	],
	"description": "this is a c++ snippet for finding all prime factors till n",
},
"binary indexed tree ": {
	"prefix": [
		"binary_index_tree"
	],
	"body": [
		"ll bit[N];",
		"int getSum(int index)",
		"{",
		"   int sum = 0; // Iniialize result",
		"   index = index + 1;// index in BITree[] is 1 more than the index in arr[]",
		"   while (index>0)// Traverse ancestors of BITree[index]",
		"   {",
		"       sum += bit[index];// Add current element of BITree to sum",
		"       index -= index & (-index);// Move index to parent node in getSum View",
		"   }",
		"   return sum;",
		"}",  
		"// Updates a node in Binary Index Tree (BITree) at given index",
		"// in BITree. The given value 'val' is added to BITree[i] and ",
		"// all of its ancestors in tree.",
		"void updateBIT(int n, int index, int val)",
		"{",
		"   // index in BITree[] is 1 more than the index in arr[] ",
		"   index = index + 1;",
		"   // Traverse all ancestors and add 'val'",
		"   while (index <= n)",
		"   {",
		"   // Add 'val' to current node of BI Tree",
		"   bit[index] += val;",
		"   // Update index to that of parent in update View",
		"   index += index & (-index);",
		"  }",
		"}", 
		"// Constructs and returns a Binary Indexed Tree for given",
		"// array of size n.",
		"void constructBITree(int arr[], int n)",
		"{",
		"    // Create and initialize BITree[] as 0",
		"    for (int i=1; i<=n; i++)",
		"    bit[i] = 0;",
		"    // Store the actual values in BITree[] using update()",
		"    for (int i=0; i<n; i++)",
		"    updateBIT(n, i, arr[i]);",
		"    // Uncomment below lines to see contents of BITree[]",
		"    //for (int i=1; i<=n; i++)",
		"}",
		"void solve()",
		"{",
		"   int arr[] = {2, 1, 1, 3, 2, 3, 4, 5, 6, 7, 8, 9};",
		"   int n = sizeof(arr)/sizeof(arr[0]);",
		"   constructBITree(arr, n);",
		"      cout<< getSum(5);",
		"   // Let use test the update operation",
		"   arr[3] += 6;",
		"   updateBIT(n, 3, 6); //Update BIT for above change in arr[]",
		"   cout<< getSum(5);",
		"}",
	],
	"description": "this is a c++ snippet for binary indexed tree",
  },
  "all the biary search related": {
	"prefix": "binary",
	"body": [
	  "",
	  "// C++ program to variants of Binary Search",
	  "#include <bits/stdc++.h>",
	  " ",
	  "using namespace std;",
	  " ",
	  "int n = 8; // array size",
	  "int a[] = { 2, 3, 3, 5, 5, 5, 6, 6 }; // Sorted array",
	  " ",
	  "/* Find if key is in array",
	  " * Returns: True if key belongs to array,",
	  " *          False if key doesn't belong to array */",
	  "bool contains(int low, int high, int key)",
	  "{",
	  "    bool ans = false;",
	  "    while (low <= high) {",
	  "        int mid = low + (high - low) / 2;",
	  "        int midVal = a[mid];",
	  " ",
	  "        if (midVal < key) {",
	  " ",
	  "            // if mid is less than key, all elements",
	  "            // in range [low, mid] are also less",
	  "            // so we now search in [mid + 1, high]",
	  "            low = mid + 1;",
	  "        }",
	  "        else if (midVal > key) {",
	  " ",
	  "            // if mid is greater than key, all elements",
	  "            // in range [mid + 1, high] are also greater",
	  "            // so we now search in [low, mid - 1]",
	  "            high = mid - 1;",
	  "        }",
	  "        else if (midVal == key) {",
	  " ",
	  "            // comparison added just for the sake",
	  "            // of clarity if mid is equal to key, we",
	  "            // have found that key exists in array",
	  "            ans = true;",
	  "            break;",
	  "        }",
	  "    }",
	  " ",
	  "    return ans;",
	  "}",
	  " ",
	  "/* Find first occurrence index of key in array",
	  " * Returns: an index in range [0, n-1] if key belongs",
	  " *          to array, -1 if key doesn't belong to array",
	  " */",
	  "int first(int low, int high, int key)",
	  "{",
	  "    int ans = -1;",
	  " ",
	  "    while (low <= high) {",
	  "        int mid = low + (high - low + 1) / 2;",
	  "        int midVal = a[mid];",
	  " ",
	  "        if (midVal < key) {",
	  " ",
	  "            // if mid is less than key, all elements",
	  "            // in range [low, mid] are also less",
	  "            // so we now search in [mid + 1, high]",
	  "            low = mid + 1;",
	  "        }",
	  "        else if (midVal > key) {",
	  " ",
	  "            // if mid is greater than key, all elements",
	  "            // in range [mid + 1, high] are also greater",
	  "            // so we now search in [low, mid - 1]",
	  "            high = mid - 1;",
	  "        }",
	  "        else if (midVal == key) {",
	  " ",
	  "            // if mid is equal to key, we note down",
	  "            //  the last found index then we search",
	  "            // for more in left side of mid",
	  "            // so we now search in [low, mid - 1]",
	  "            ans = mid;",
	  "            high = mid - 1;",
	  "        }",
	  "    }",
	  " ",
	  "    return ans;",
	  "}",
	  " ",
	  "/* Find last occurrence index of key in array",
	  " * Returns: an index in range [0, n-1] if key",
	  "             belongs to array,",
	  " *          -1 if key doesn't belong to array",
	  " */",
	  "int last(int low, int high, int key)",
	  "{",
	  "    int ans = -1;",
	  " ",
	  "    while (low <= high) {",
	  "        int mid = low + (high - low + 1) / 2;",
	  "        int midVal = a[mid];",
	  " ",
	  "        if (midVal < key) {",
	  " ",
	  "            // if mid is less than key, then all elements",
	  "            // in range [low, mid - 1] are also less",
	  "            // so we now search in [mid + 1, high]",
	  "            low = mid + 1;",
	  "        }",
	  "        else if (midVal > key) {",
	  " ",
	  "            // if mid is greater than key, then all",
	  "            // elements in range [mid + 1, high] are",
	  "            // also greater so we now search in",
	  "            // [low, mid - 1]",
	  "            high = mid - 1;",
	  "        }",
	  "        else if (midVal == key) {",
	  " ",
	  "            // if mid is equal to key, we note down",
	  "            // the last found index then we search",
	  "            // for more in right side of mid",
	  "            // so we now search in [mid + 1, high]",
	  "            ans = mid;",
	  "            low = mid + 1;",
	  "        }",
	  "    }",
	  " ",
	  "    return ans;",
	  "}",
	  " ",
	  "/* Find index of first occurrence of least element",
	  "   greater than key in array",
	  " * Returns: an index in range [0, n-1] if key is not",
	  "             the greatest element in array,",
	  " *          -1 if key is the greatest element in array */",
	  "int leastgreater(int low, int high, int key)",
	  "{",
	  "    int ans = -1;",
	  " ",
	  "    while (low <= high) {",
	  "        int mid = low + (high - low + 1) / 2;",
	  "        int midVal = a[mid];",
	  " ",
	  "        if (midVal < key) {",
	  " ",
	  "            // if mid is less than key, all elements",
	  "            // in range [low, mid - 1] are <= key",
	  "            // then we search in right side of mid",
	  "            // so we now search in [mid + 1, high]",
	  "            low = mid + 1;",
	  "        }",
	  "        else if (midVal > key) {",
	  " ",
	  "            // if mid is greater than key, all elements",
	  "            // in range [mid + 1, high] are >= key",
	  "            // we note down the last found index, then",
	  "            // we search in left side of mid",
	  "            // so we now search in [low, mid - 1]",
	  "            ans = mid;",
	  "            high = mid - 1;",
	  "        }",
	  "        else if (midVal == key) {",
	  " ",
	  "            // if mid is equal to key, all elements in",
	  "            // range [low, mid] are <= key",
	  "            // so we now search in [mid + 1, high]",
	  "            low = mid + 1;",
	  "        }",
	  "    }",
	  " ",
	  "    return ans;",
	  "}",
	  " ",
	  "/* Find index of last occurrence of greatest element",
	  "   less than key in array",
	  " * Returns: an index in range [0, n-1] if key is not",
	  "             the least element in array,",
	  " *          -1 if key is the least element in array */",
	  "int greatestlesser(int low, int high, int key)",
	  "{",
	  "    int ans = -1;",
	  " ",
	  "    while (low <= high) {",
	  "        int mid = low + (high - low + 1) / 2;",
	  "        int midVal = a[mid];",
	  " ",
	  "        if (midVal < key) {",
	  " ",
	  "            // if mid is less than key, all elements",
	  "            // in range [low, mid - 1] are < key",
	  "            // we note down the last found index, then",
	  "            // we search in right side of mid",
	  "            // so we now search in [mid + 1, high]",
	  "            ans = mid;",
	  "            low = mid + 1;",
	  "        }",
	  "        else if (midVal > key) {",
	  " ",
	  "            // if mid is greater than key, all elements",
	  "            // in range [mid + 1, high] are > key",
	  "            // then we search in left side of mid",
	  "            // so we now search in [low, mid - 1]",
	  "            high = mid - 1;",
	  "        }",
	  "        else if (midVal == key) {",
	  " ",
	  "            // if mid is equal to key, all elements",
	  "            // in range [mid + 1, high] are >= key",
	  "            // then we search in left side of mid",
	  "            // so we now search in [low, mid - 1]",
	  "            high = mid - 1;",
	  "        }",
	  "    }",
	  " ",
	  "    return ans;",
	  "}",
	  " ",
	  "int main()",
	  "{",
	  "    printf(\"Contains\\n\");",
	  "    for (int i = 0; i < 10; i++)",
	  "        printf(\"%d %d\\n\", i, contains(0, n - 1, i));",
	  " ",
	  "    printf(\"First occurrence of key\\n\");",
	  "    for (int i = 0; i < 10; i++)",
	  "        printf(\"%d %d\\n\", i, first(0, n - 1, i));",
	  " ",
	  "    printf(\"Last occurrence of key\\n\");",
	  "    for (int i = 0; i < 10; i++)",
	  "        printf(\"%d %d\\n\", i, last(0, n - 1, i));",
	  " ",
	  "    printf(\"Least integer greater than key\\n\");",
	  "    for (int i = 0; i < 10; i++)",
	  "        printf(\"%d %d\\n\", i, leastgreater(0, n - 1, i));",
	  " ",
	  "    printf(\"Greatest integer lesser than key\\n\");",
	  "    for (int i = 0; i < 10; i++)",
	  "        printf(\"%d %d\\n\", i, greatestlesser(0, n - 1, i));",
	  " ",
	  "    return 0;",
	  "}"
	],
	"description": "all the biary search related"
  },
  "for tree binary lifting": {
	"prefix": "binary_lifting",
	"body": [
	  "vector<int> trees[200001];",
	  "int up[200001][20];",
	  " ",
	  "void binary_lifting(int src, int par)",
	  "{",
	  "    up[src][0] = par;",
	  "    for(int i = 1; i < 20; i++)",
	  "    {",
	  "        if(up[src][i-1] != -1)",
	  "            up[src][i] = up[up[src][i-1]][i-1];",
	  "        else up[src][i] = -1;",
	  "    }",
	  " ",
	  "    for(int child : trees[src])",
	  "    {",
	  "        if(child != par)",
	  "            binary_lifting(child, src);",
	  "    }",
	  "}",
	  " ",
	  "int ans_query(int node, int jump_required)",
	  "{",
	  "    if(node == -1 || jump_required == 0)",
	  "        return node;",
	  " ",
	  "    for(int i = 19; i >= 0; i--){",
	  "        if(jump_required >= (1<<i)){",
	  "            return ans_query(up[node][i], jump_required - (1<<i));",
	  "        }",
	  "    }",
	  "}",
	  " ",
	  "int main() {",
	  "   fast_io;",
	  "   ll t,n,m,x,i,j,k,q;",
	  "   //cin >> t;",
	  "   t = 1;",
	  "   while(t--)",
	  "   {",
	  "        cin >> n >> q;",
	  "        fr(2,n+1)",
	  "        {",
	  "            cin >> x;",
	  "            trees[x].push_back(i);",
	  "            trees[i].push_back(x);",
	  "        }",
	  "        binary_lifting(1, -1);",
	  "        while(q--){",
	  "            int node, k;",
	  "            cin >> node >> k;",
	  "            cout << ans_query(node, k) << '\\n';",
	  "        }",
	  "   }",
	  "   return 0;",
	  "}"
	],
	"description": "for tree binary lifting"
  },
  "lca calculation in log(n) time": {
	"prefix": "lca",
	"body": [
	  "",
	  "int levels[200001];",
	  "vector<int> trees[200001];",
	  "int up[200001][20];",
	  "void level(int src,int par,int l)",
	  "{",
	  "    levels[src]=l;",
	  "    for(auto it:trees[src])",
	  "    {",
	  "        if(it!=par)",
	  "        {",
	  "            level(it,src,l+1);",
	  "        }",
	  "    }",
	  "",
	  "}",
	  "void binary_lifting(int src, int par)",
	  "{",
	  "    up[src][0] = par;",
	  "    for(int i = 1; i < 20; i++)",
	  "    {",
	  "        if(up[src][i-1] != -1)",
	  "            up[src][i] = up[up[src][i-1]][i-1];",
	  "        else up[src][i] = -1;",
	  "    }",
	  " ",
	  "    for(int child : trees[src])",
	  "    {",
	  "        if(child != par)",
	  "            binary_lifting(child, src);",
	  "    }",
	  "}",
	  " ",
	  "int lift(int node, int jump_required)",
	  "{",
	  "    if(node == -1 || jump_required == 0)",
	  "        return node;",
	  " ",
	  "    for(int i = 19; i >= 0; i--){",
	  "        if(jump_required >= (1<<i)){",
	  "            return lift(up[node][i], jump_required - (1<<i));",
	  "        }",
	  "    }",
	  "}",
	  "int ans_query(int u,int v)",
	  "{",
	  "    if(levels[u]<levels[v])",
	  "    {",
	  "        swap(u,v);",
	  "    }",
	  "    // cout<<levels[u]<<\" \"<<levels[v]<<ed;",
	  "    int l=levels[u]-levels[v];",
	  "    u=lift(u,l);",
	  "    if(u==v)",
	  "    {",
	  "        return(u);",
	  "    }",
	  "for(int i=19;i>=0;i--)",
	  "{",
	  "    if(up[u][i]!=up[v][i])",
	  "    {",
	  "        u=up[u][i];",
	  "        v=up[v][i];",
	  "    }",
	  "}",
	  "    return(lift(u,1));",
	  "}",
	  "int32_t main() {",
	  "",
	  "   ll t,n,m,x,i,j,k,q;",
	  "   //cin >> t;",
	  "   t = 1;",
	  "   while(t--)",
	  "   {",
	  "        cin >> n >> q;",
	  "        for(int i=2;i<=n;i++)",
	  "        {",
	  "            cin >> x;",
	  "            trees[x].push_back(i);",
	  "            trees[i].push_back(x);",
	  "        }",
	  "        level(1,0,0);",
	  "        binary_lifting(1, -1);",
	  "        while(q--){",
	  "            int node1, node2;",
	  "            cin >> node1 >> node2;",
	  "            cout << ans_query(node1, node2) << '\\n';",
	  "        }",
	  "   }",
	  "   return 0;",
	  "}"
	],
	"description": "lca calculation in log(n) time"
  },
  "finding the count of divisors of a number int nlogn": {
	"prefix": "countingdivisors",
	"body": [
	  "int d[N];",
	  "void countingdivisors()",
	  "{",
	  "    for(int i=1;i<=N;i++)",
	  "    {",
	  "        for(int j=i;j<=N;j+=i)",
	  "        {",
	  "            d[j]++;",
	  "        }",
	  "    }",
	  "}"
	],
	"description": "finding the count of divisors of a number int nlogn"
  },
  "z_funtion calculation": {
	"prefix": "z_funtion",
	"body": [
	  "vector<int> z_function(string s) {",
	  "    int n = (int) s.length();",
	  "    vector<int> z(n);",
	  "    for (int i = 1, l = 0, r = 0; i < n; ++i) {",
	  "        if (i <= r)",
	  "            z[i] = min (r - i + 1, z[i - l]);",
	  "        while (i + z[i] < n && s[z[i]] == s[i + z[i]])",
	  "            ++z[i];",
	  "        if (i + z[i] - 1 > r)",
	  "            l = i, r = i + z[i] - 1;",
	  "    }",
	  "    return z;",
	  "}",
	  ""
	],
	"description": "z_funtion calculation"
  },
  "substring counting(unique substring counting)": {
	"prefix": "substring_counting",
	"body": [
	  "int count_unique_substrings(string const& s) {",
	  "    int n = s.size();",
	  "",
	  "    const int p = 31;",
	  "    const int m = 1e9 + 9;",
	  "    vector<long long> p_pow(n);",
	  "    p_pow[0] = 1;",
	  "    for (int i = 1; i < n; i++)",
	  "        p_pow[i] = (p_pow[i-1] * p) % m;",
	  "",
	  "    vector<long long> h(n + 1, 0);",
	  "    for (int i = 0; i < n; i++)",
	  "        h[i+1] = (h[i] + (s[i] - 'a' + 1) * p_pow[i]) % m;",
	  "",
	  "    int cnt = 0;",
	  "    for (int l = 1; l <= n; l++) {",
	  "        set<long long> hs;",
	  "        for (int i = 0; i <= n - l; i++) {",
	  "            long long cur_h = (h[i + l] + m - h[i]) % m;",
	  "            cur_h = (cur_h * p_pow[n-i-1]) % m;",
	  "            hs.insert(cur_h);",
	  "        }",
	  "        cnt += hs.size();",
	  "    }",
	  "    return cnt;",
	  "}"
	],
	"description": "substring counting(unique substring counting)"
  },
  "hash computing funtion": {
	"prefix": "compute_hash",
	"body": [
	  "long long compute_hash(string const& s) {",
	  "    const int p = 31;",
	  "    const int m = 1e9 + 9;",
	  "    long long hash_value = 0;",
	  "    long long p_pow = 1;",
	  "    for (char c : s) {",
	  "        hash_value = (hash_value + (c - 'a' + 1) * p_pow) % m;",
	  "        p_pow = (p_pow * p) % m;",
	  "    }",
	  "    return hash_value;",
	  "}"
	],
	"description": "hash computing funtion"
  },
  "rabin karp algorithm for calculating all occourances of a pattern in a given string": {
	"prefix": "rabin_karp",
	"body": [
	  "vector<int> rabin_karp(string const& s, string const& t) {",
	  "    const int p = 31; ",
	  "    const int m = 1e9 + 9;",
	  "    int S = s.size(), T = t.size();",
	  "",
	  "    vector<long long> p_pow(max(S, T)); ",
	  "    p_pow[0] = 1; ",
	  "    for (int i = 1; i < (int)p_pow.size(); i++) ",
	  "        p_pow[i] = (p_pow[i-1] * p) % m;",
	  "",
	  "    vector<long long> h(T + 1, 0); ",
	  "    for (int i = 0; i < T; i++)",
	  "        h[i+1] = (h[i] + (t[i] - 'a' + 1) * p_pow[i]) % m; ",
	  "    long long h_s = 0; ",
	  "    for (int i = 0; i < S; i++) ",
	  "        h_s = (h_s + (s[i] - 'a' + 1) * p_pow[i]) % m; ",
	  "",
	  "    vector<int> occurences;",
	  "    for (int i = 0; i + S - 1 < T; i++) { ",
	  "        long long cur_h = (h[i+S] + m - h[i]) % m; ",
	  "        if (cur_h == h_s * p_pow[i] % m)",
	  "            occurences.push_back(i);",
	  "    }",
	  "    return occurences;",
	  "}"
	],
	"description": "rabin karp algorithm for calculating all occourances of a pattern in a given string"
  },
  "ncr calculation without modulo": {
	"prefix": "ncr",
	"body": [
	  "ll ncr(ll n,ll r) ",
	  "{",
	  "    long long p = 1, k = 1; ",
	  "    if (n - r < r)  r = n - r; ",
	  "    if (r != 0)",
	  "        while (r) ",
	  "        { ",
	  "            p *= n; ",
	  "            k *= r;",
	  "            long long m = __gcd(p, k);",
	  "            p /= m; ",
	  "            k /= m; ",
	  "            n--,r--;",
	  "        }  ",
	  "    else",
	  "        p = 1; ",
	  "    return p ; ",
	  "} "
	],
	"description": "ncr calculation without modulo"
  }
}
